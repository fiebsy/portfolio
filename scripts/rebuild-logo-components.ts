import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

const LOGOS_DIR = path.join(process.cwd(), 'src/components/icons/logos');
const SVG_DIR = path.join(process.cwd(), 'public/svg/logos');
const EXCLUDED_FILES = ['index.ts', 'types.ts', 'color-mappings.ts'];

interface SvgColors {
  fills: string[];
  gradients: {
    id: string;
    definition: string;
  }[];
}

async function cleanDirectory() {
  // Read all files in the logos directory
  const files = await fs.promises.readdir(LOGOS_DIR);
  
  // Delete all files except excluded ones
  for (const file of files) {
    if (!EXCLUDED_FILES.includes(file)) {
      await fs.promises.unlink(path.join(LOGOS_DIR, file));
    }
  }
  
  console.log('✨ Cleaned existing components');
}

function extractColorsFromSvg(svgContent: string): SvgColors {
  const fills: string[] = [];
  const gradients: { id: string; definition: string }[] = [];
  
  // Extract fill colors
  const fillMatches = svgContent.match(/fill="([^"]+)"/g);
  if (fillMatches) {
    fills.push(...fillMatches
      .map(match => match.match(/fill="([^"]+)"/)?.[1] || '')
      .filter(color => color !== 'none' && !color.startsWith('url(#')));
  }
  
  // Extract gradients
  const gradientMatches = svgContent.match(/<(linearGradient|radialGradient)[^>]*>[\s\S]*?<\/(linearGradient|radialGradient)>/g);
  if (gradientMatches) {
    gradientMatches.forEach(gradient => {
      const idMatch = gradient.match(/id="([^"]+)"/);
      if (idMatch) {
        gradients.push({
          id: idMatch[1],
          definition: gradient
        });
      }
    });
  }
  
  return { fills, gradients };
}

function svgToJsx(svgContent: string): string {
  // Convert kebab-case attributes to camelCase for JSX
  let jsxContent = svgContent.replace(/([a-z]+)-([a-z]+)="([^"]+)"/g, (match, p1, p2, p3) => {
    const camelCaseAttr = p1 + p2.charAt(0).toUpperCase() + p2.slice(1);
    // Only convert known problematic attributes for now
    if (['clipRule', 'stopColor', 'fillRule', 'strokeWidth', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'xmlSpace', 'gradientUnits'].includes(camelCaseAttr)) {
      return `${camelCaseAttr}="${p3}"`;
    }
    return match; // Keep original if not a known attribute needing conversion
  });
  
  // Remove namespace URIs like xmlns:xlink (React doesn't need them)
  jsxContent = jsxContent.replace(/xmlns:xlink="[^"]+"/g, '');
  
  return jsxContent;
}

function generateCustomizableComponent(componentName: string, svgContent: string): string {
  // Remove fill attributes and add dynamic fill
  const cleanedSvg = svgContent
    .replace(/fill="[^"]+"/g, '')
    .replace(/<(path|circle|rect|g)/g, '<$1 fill={color || \'currentColor\'}');

  return `import { CustomizableLogoProps } from './types';

export const ${componentName}Logo = ({ size = 24, color, ...props }: CustomizableLogoProps) => {
  return (
    ${cleanedSvg.replace(/<svg[^>]+>/, `<svg
      width={size}
      height={size}
      viewBox="0 0 32 32"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >`)}
  );
};

export default ${componentName}Logo;`;
}

function generateBrandColorComponent(componentName: string, svgContent: string, colors: SvgColors): string {
  let svg = svgContent;
  
  // If there are gradients, keep them in the defs section
  if (colors.gradients.length > 0) {
    const defs = colors.gradients.map(g => g.definition).join('\n    ');
    svg = svg.replace(/<defs>[\s\S]*?<\/defs>/, `<defs>\n    ${defs}\n  </defs>`);
  }

  // Convert SVG attributes to JSX
  const jsxSvg = svgToJsx(svg);

  return `import { BrandLogoProps } from './types';

export const ${componentName}ColorLogo = ({ size = 24, ...props }: BrandLogoProps) => {
  return (
    ${jsxSvg.replace(/<svg[^>]+>/, `<svg
      width={size}
      height={size}
      // Use a default viewBox or extract from SVG if needed
      viewBox="0 0 24 24" // Assuming 24x24, adjust if necessary
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >`)}
  );
};

export default ${componentName}ColorLogo;`;
}

async function generateComponents() {
  // Read all SVG files
  const svgFiles = await fs.promises.readdir(SVG_DIR);
  
  // Separate color SVGs from others
  const colorSvgs = svgFiles.filter(file => file.includes('-color.svg'));
  const otherSvgs = svgFiles.filter(file => !file.includes('-color.svg'));
  
  // Generate index.ts content
  let indexContent = `// Generated by scripts/rebuild-logo-components.ts
export * from './types';\n\n`;
  
  // Process color SVGs -> Generate *ColorLogo.tsx
  for (const svgFile of colorSvgs) {
    const componentName = svgFile
      .replace('-color.svg', '')
      .split(/[-_]/)
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
    
    const svgContent = await fs.promises.readFile(
      path.join(SVG_DIR, svgFile),
      'utf-8'
    );
    
    const colors = extractColorsFromSvg(svgContent);
    const brandColored = generateBrandColorComponent(componentName, svgContent, colors);
    
    await fs.promises.writeFile(
      path.join(LOGOS_DIR, `${componentName}ColorLogo.tsx`),
      brandColored
    );
    
    indexContent += `export * from './${componentName}ColorLogo';\n`;
  }
  
  // Process other SVGs -> Generate *Logo.tsx (customizable)
  for (const svgFile of otherSvgs) {
    // Special handling for Whop white logo (use orange for customizable base)
    let processedSvgFile = svgFile;
    if (svgFile === 'whop_logo_brandmark_white.svg') {
      processedSvgFile = 'whop_logo_brandmark_orange.svg';
      // Skip generating customizable WhopLogo if orange doesn't exist
      if (!fs.existsSync(path.join(SVG_DIR, processedSvgFile))) continue;
    }

    const componentName = processedSvgFile
      .replace('.svg', '')
      .split(/[-_]/)
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
    
    const svgContent = await fs.promises.readFile(
      path.join(SVG_DIR, processedSvgFile),
      'utf-8'
    );
    
    const customizable = generateCustomizableComponent(componentName, svgContent);
    
    await fs.promises.writeFile(
      path.join(LOGOS_DIR, `${componentName}Logo.tsx`),
      customizable
    );
    
    indexContent += `export * from './${componentName}Logo';\n`;
  }
  
  // Write index.ts
  await fs.promises.writeFile(
    path.join(LOGOS_DIR, 'index.ts'),
    indexContent
  );
  
  // Update types.ts
  const typesContent = `import { SVGProps } from 'react';

export interface BaseLogoProps extends SVGProps<SVGSVGElement> {
  size?: number | string;
}

export interface CustomizableLogoProps extends BaseLogoProps {
  color?: string;
}

export interface BrandLogoProps extends BaseLogoProps {
  // No color prop - uses brand colors only
}

export const BRAND_COLORS = {
  typescript: '#3178C6',
  react: '#61DAFB',
  nextjs: '#000000',
  tailwind: '#38BDF8',
  firebase: '#FFCA28',
  figma: '#F24E1E',
  framer: '#0055FF',
  bigquery: '#4285F4',
  lottie: '#00D1C1',
  whop: '#FF6243'
} as const;

export type BrandColor = keyof typeof BRAND_COLORS;`;

  await fs.promises.writeFile(
    path.join(LOGOS_DIR, 'types.ts'),
    typesContent
  );
  
  // Run prettier
  await execAsync('npx prettier --write "src/components/icons/logos/**/*.{ts,tsx}"');
  
  console.log('✨ Generated new components based on file type');
}

async function main() {
  try {
    await cleanDirectory();
    await generateComponents();
    console.log('✅ Logo components rebuilt successfully');
  } catch (error) {
    console.error('❌ Error rebuilding components:', error);
    process.exit(1);
  }
}

main(); 