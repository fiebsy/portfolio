import fs from 'fs';
import path from 'path';

interface ColorMapping {
  sourceFile: string;
  componentName: string;
  variants: {
    color: {
      file: string;
      colors: {
        primary: string;
        accent?: string;
      };
    };
    monochrome: {
      file: string;
    };
  };
}

const SOURCE_DIR = 'public/svg/logos';

// Map of component names to their variant files
const VARIANT_PAIRS = [
  {
    componentName: 'TypeScript',
    color: 'ts-color.svg',
    monochrome: 'ts-neutral.svg',
  },
  {
    componentName: 'React',
    color: 'react-color.svg',
    monochrome: 'react.svg',
  },
  {
    componentName: 'Tailwind',
    color: 'tailwind-color.svg',
    monochrome: 'tailwind.svg',
  },
  {
    componentName: 'Firebase',
    color: 'firebase-color.svg',
    monochrome: 'firebase.svg',
  },
  {
    componentName: 'Figma',
    color: 'figma-color.svg',
    monochrome: 'figma.svg',
  },
  {
    componentName: 'Framer',
    color: 'framer-color.svg',
    monochrome: 'framer.svg',
  },
  {
    componentName: 'Whop',
    color: 'whop_logo_brandmark_orange.svg',
    monochrome: 'whop_logo_brandmark_white.svg',
  },
];

function extractColors(svgContent: string): { primary: string; accent?: string } {
  const colors: string[] = [];
  
  // Extract fill colors
  const fillMatches = svgContent.match(/fill="([^"]*)"/g);
  if (fillMatches) {
    fillMatches.forEach(match => {
      const color = match.match(/fill="([^"]*)"/)?.[1];
      if (color && color !== 'none' && !colors.includes(color)) {
        colors.push(color);
      }
    });
  }

  // Extract stroke colors
  const strokeMatches = svgContent.match(/stroke="([^"]*)"/g);
  if (strokeMatches) {
    strokeMatches.forEach(match => {
      const color = match.match(/stroke="([^"]*)"/)?.[1];
      if (color && color !== 'none' && !colors.includes(color)) {
        colors.push(color);
      }
    });
  }

  // Identify primary and accent colors
  // Primary is usually the first non-white color
  // Accent is usually white or the second most used color
  const primary = colors.find(c => c.toLowerCase() !== '#fff' && c.toLowerCase() !== '#ffffff') || colors[0];
  const accent = colors.find(c => c.toLowerCase() === '#fff' || c.toLowerCase() === '#ffffff');

  return {
    primary,
    ...(accent && { accent }),
  };
}

function generateColorMappings(): ColorMapping[] {
  const mappings: ColorMapping[] = [];

  VARIANT_PAIRS.forEach(({ componentName, color, monochrome }) => {
    const colorPath = path.join(SOURCE_DIR, color);
    const monochromePath = path.join(SOURCE_DIR, monochrome);

    if (!fs.existsSync(colorPath) || !fs.existsSync(monochromePath)) {
      console.warn(`Missing variant files for ${componentName}`);
      return;
    }

    const colorContent = fs.readFileSync(colorPath, 'utf-8');
    const colors = extractColors(colorContent);

    mappings.push({
      sourceFile: color,
      componentName,
      variants: {
        color: {
          file: color,
          colors,
        },
        monochrome: {
          file: monochrome,
        },
      },
    });
  });

  return mappings;
}

function writeColorMappings(mappings: ColorMapping[]) {
  const outputPath = path.join('src/components/icons/logos', 'color-mappings.ts');
  
  const content = `// Generated by scripts/utils/generate-color-mappings.ts
export interface ColorMapping {
  sourceFile: string;
  componentName: string;
  variants: {
    color: {
      file: string;
      colors: {
        primary: string;
        accent?: string;
      };
    };
    monochrome: {
      file: string;
    };
  };
}

export const COLOR_MAPPINGS: ColorMapping[] = ${JSON.stringify(mappings, null, 2)};
`;

  fs.writeFileSync(outputPath, content);
  console.log('âœ“ Generated color mappings');
}

// Run the script
const mappings = generateColorMappings();
writeColorMappings(mappings); 